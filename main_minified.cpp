#include<bits/stdc++.h>
using Pattern=std::array<bool,8>;constexpr int comb(int n,int k){int ans=1;for(int i=0;i<k;++i){ans*=n-i;ans/=i+1;}return ans;}constexpr std::array<Pattern,256>gen_pattern_list(){int tail[9]={0};for(int i=0;i<8;++i){tail[i+1]=tail[i]+comb(8,i);}std::array<Pattern,256>patterns={};for(int i=0;i<256;++i){int count=__builtin_popcount(i);for(int j=0;j<8;++j){patterns[tail[count]][j]=(i>>j)& 1;}tail[count]++;}return patterns;}constexpr std::array<std::pair<int,int>,9>gen_pattern_range_for_count(){std::array<std::pair<int,int>,9>ranges={};int bounds[10]={0};for(int i=0;i<=8;++i){bounds[i+1]=bounds[i]+comb(8,i);}for(int i=0;i<=8;++i){ranges[i].first=bounds[i];ranges[i].second=bounds[i+1];}return ranges;}static constexpr std::array<Pattern,256>pattern_list=gen_pattern_list();static constexpr std::array<std::pair<int,int>,9>pattern_range_for_count=gen_pattern_range_for_count();constexpr std::pair<int,int>neighbors[]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};constexpr std::pair<int,int>neighbors_two[]={{-2,-2},{-2,-1},{-2,0},{-2,1},{-2,2},{-1,-2},{-1,-1},{-1,0},{-1,1},{-1,2},{0,-2},{0,-1},{0,1},{0,2},{1,-2},{1,-1},{1,0},{1,1},{1,2},{2,-2},{2,-1},{2,0},{2,1},{2,2}};enum class SearchState{Undetermined=0,Safe=1,Mine=2};struct PatternReference{uint8_t index;PatternReference(const Pattern &pattern){index=std::addressof(pattern)-std::addressof(pattern_list[0]);}operator const Pattern &()const{return get();}const Pattern &get()const{return pattern_list[index];}bool operator==(const PatternReference &other)const{return index==other.index;}bool operator<(const PatternReference &other)const{return index<other.index;}bool operator[](size_t i)const{return get()[i];}};struct Solver{int w,h;std::vector<std::vector<int>>board;std::vector<std::vector<bool>>opened;std::vector<std::vector<SearchState>>state;std::set<std::pair<int,int>>cells_to_evaluate;std::vector<std::vector<std::set<PatternReference>>>remaining_pattern;Solver(std::vector<std::vector<int>>&board,int w,int h):board(board),w(w),h(h),opened(h,std::vector<bool>(w,false)),state(h,std::vector<SearchState>(w,SearchState::Undetermined)),remaining_pattern(h,std::vector<std::set<PatternReference>>(w,std::set<PatternReference>())){}void apply_pattern(int r,int c,const Pattern &pattern){for(int i=0;i<8;++i){int nr=r+neighbors[i].first;int nc=c+neighbors[i].second;if(nr<0||nr>=h||nc<0||nc>=w)continue;if(pattern[i]){state[nr][nc]=SearchState::Mine;}else{state[nr][nc]=SearchState::Safe;}}}bool pattern_check(int r,int c,const Pattern &pattern){for(int i=0;i<8;++i){int nr=r+neighbors[i].first;int nc=c+neighbors[i].second;if(nr<0||nr>=h||nc<0||nc>=w){if(pattern[i]){return false;}continue;}if(state[nr][nc]==SearchState::Mine && !pattern[i]){return false;}if(state[nr][nc]==SearchState::Safe && pattern[i]){return false;}}return true;}bool board_number_check(int r,int c){int mine=0,undetermined=0;for(auto[dr,dc]:neighbors){int nr=r+dr,nc=c+dc;if(nr<0||nr>=h||nc<0||nc>=w)continue;if(state[nr][nc]==SearchState::Mine){mine++;}else if(state[nr][nc]==SearchState::Undetermined){undetermined++;}}assert(opened[r][c]);return mine<=board[r][c]&& undetermined>=board[r][c]-mine;}std::array<SearchState,8>get_neighbors_state(int r,int c){std::array<SearchState,8>neighbor_states;for(int i=0;i<8;++i){int nr=r+neighbors[i].first;int nc=c+neighbors[i].second;if(nr<0||nr>=h||nc<0||nc>=w){neighbor_states[i]=SearchState::Undetermined;}else{neighbor_states[i]=state[nr][nc];}}return neighbor_states;}void set_neighbors_state(int r,int c,const std::array<SearchState,8>&neighbor_states){for(int i=0;i<8;++i){int nr=r+neighbors[i].first;int nc=c+neighbors[i].second;if(nr<0||nr>=h||nc<0||nc>=w)continue;state[nr][nc]=neighbor_states[i];}}void confirm_to_be_safe(int r,int c){std::cout<<c<<" "<<r<<"\n";if(board[r][c]==9){confirm_to_be_mine(r,c);return;}opened[r][c]=true;state[r][c]=SearchState::Safe;cells_to_evaluate.emplace(r,c);auto[first,last]=pattern_range_for_count[board[r][c]];for(int i=first;i<last;++i){const auto &p=pattern_list[i];remaining_pattern[r][c].emplace(p);}for(const auto &[dr,dc]:neighbors){int nr=r+dr,nc=c+dc;if(nr<0||nr>=h||nc<0||nc>=w)continue;if(state[nr][nc]==SearchState::Safe){cells_to_evaluate.emplace(nr,nc);}}}void confirm_to_be_mine(int r,int c){state[r][c]=SearchState::Mine;for(const auto &[dr,dc]:neighbors){int nr=r+dr,nc=c+dc;if(nr<0||nr>=h||nc<0||nc>=w)continue;if(state[nr][nc]==SearchState::Safe){cells_to_evaluate.emplace(nr,nc);}}}void confirm_common_elements(int r,int c){if(remaining_pattern[r][c].empty())return;std::array<bool,8>differ={};const Pattern &reference_pattern=*remaining_pattern[r][c].begin();for(const auto &pattern:remaining_pattern[r][c]){for(int i=0;i<8;++i){differ[i]|=reference_pattern[i]!=pattern[i];}}for(int i=0;i<8;++i){if(!differ[i]){int nr=r+neighbors[i].first;int nc=c+neighbors[i].second;if(nr<0||nr>=h||nc<0||nc>=w)continue;if(state[nr][nc]==SearchState::Undetermined){if(reference_pattern[i]){confirm_to_be_mine(nr,nc);}else{confirm_to_be_safe(nr,nc);}}}}}void simple_algorithm(){while(!cells_to_evaluate.empty()){auto[r,c]=*cells_to_evaluate.begin();cells_to_evaluate.erase(cells_to_evaluate.begin());for(auto it=remaining_pattern[r][c].begin();it !=remaining_pattern[r][c].end();){auto &pattern=*it;if(!pattern_check(r,c,pattern)){it=remaining_pattern[r][c].erase(it);continue;}auto saved_state=get_neighbors_state(r,c);apply_pattern(r,c,pattern);bool valid=true;for(const auto &[dr,dc]:neighbors_two){int nr=r+dr,nc=c+dc;if(nr<0||nr>=h||nc<0||nc>=w)continue;if(!opened[nr][nc])continue;if(!board_number_check(nr,nc)){valid=false;break;}}set_neighbors_state(r,c,saved_state);if(valid){++it;}else{it=remaining_pattern[r][c].erase(it);}}assert(!remaining_pattern[r][c].empty());confirm_common_elements(r,c);}}bool recursive_search(const std::vector<std::pair<int,int>>&search_list,int search_index=0){if(search_index==search_list.size()){return true;}auto[r,c]=search_list[search_index];for(const auto &pattern:remaining_pattern[r][c]){if(!pattern_check(r,c,pattern))continue;auto saved_state=get_neighbors_state(r,c);apply_pattern(r,c,pattern);bool found=recursive_search(search_list,search_index+1);set_neighbors_state(r,c,saved_state);if(found){return true;}}return false;}bool recursive_algorithm(){static const std::pair<int,int>search_order[]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1},{-2,-2},{-2,-1},{-2,0},{-2,1},{-2,2},{-1,-2},{-1,2},{0,-2},{0,2},{1,-2},{1,2},{2,-2},{2,-1},{2,0},{2,1},{2,2},};bool pattern_removed=false;for(int r=0;r<h;++r){for(int c=0;c<w;++c){if(!opened[r][c])continue;if(remaining_pattern[r][c].size()<=1)continue;std::vector<std::pair<int,int>>search_list;for(auto[dr,dc]:search_order){int nr=r+dr,nc=c+dc;if(nr<0||nr>=h||nc<0||nc>=w||!opened[nr][nc]){continue;}search_list.emplace_back(nr,nc);}int before_size=remaining_pattern[r][c].size();for(auto it=remaining_pattern[r][c].begin();it !=remaining_pattern[r][c].end();){const auto &pattern=*it;if(!pattern_check(r,c,pattern)){it=remaining_pattern[r][c].erase(it);continue;}auto saved_state=get_neighbors_state(r,c);apply_pattern(r,c,pattern);bool found=recursive_search(search_list);set_neighbors_state(r,c,saved_state);if(found){++it;}else{it=remaining_pattern[r][c].erase(it);}}int after_size=remaining_pattern[r][c].size();if(before_size !=after_size){pattern_removed=true;confirm_common_elements(r,c);}}}return pattern_removed;}int count_undetermined_cells()const{int count=0;for(int r=0;r<h;++r){for(int c=0;c<w;++c){if(state[r][c]==SearchState::Undetermined){count++;}}}return count;}bool destiny_flip(){double min_probability=std::numeric_limits<double>::max();std::pair<int,int>best_cell={-1,-1};for(int r=0;r<h;++r){for(int c=0;c<w;++c){if(opened[r][c]){if(remaining_pattern[r][c].size()<=1)continue;int mine_count[8]={};for(auto &pattern:remaining_pattern[r][c]){for(int i=0;i<8;++i){mine_count[i]+=pattern[i];}}for(int i=0;i<8;++i){if(mine_count[i]>0){double probability=static_cast<double>(mine_count[i])/remaining_pattern[r][c].size();if(probability<min_probability){min_probability=probability;best_cell={r+neighbors[i].first,c+neighbors[i].second};}}}}}}if(min_probability<1 &&(count_undetermined_cells()*4-20*min_probability>0)){auto[r,c]=best_cell;confirm_to_be_safe(r,c);return true;}return false;}void solve(){std::vector<std::pair<int,int>>first_to_open;first_to_open.emplace_back(0,0);first_to_open.emplace_back(0,w-1);first_to_open.emplace_back(h-1,0);first_to_open.emplace_back(h-1,w-1);first_to_open.emplace_back(h/2,w/2);if(h%2==0)first_to_open.emplace_back(h/2-1,w/2);if(w%2==0)first_to_open.emplace_back(h/2,w/2-1);if(h%2==0 && w%2==0)first_to_open.emplace_back(h/2-1,w/2-1);for(const auto &[r,c]:first_to_open){confirm_to_be_safe(r,c);}while(!cells_to_evaluate.empty()){simple_algorithm();bool pattern_removed;do{pattern_removed=recursive_algorithm();}while(pattern_removed && cells_to_evaluate.empty());if(!pattern_removed && cells_to_evaluate.empty()){destiny_flip();}}}};int main(int argc,char*argv[]){std::string filename;if(argc>=2){filename=argv[1];}else{filename="input.txt";}std::ifstream infile(filename);std::string line;while(std::getline(infile,line)){if(line.empty())continue;std::istringstream iss(line);int h,w;std::string board_name;iss>>w>>h>>board_name;std::vector<std::vector<int>>board(h,std::vector<int>(w));for(int i=0;i<h;++i){for(int j=0;j<w;++j){char c;infile>>c;board[i][j]=c-'0';}}std::cout<<w<<" "<<h<<" "<<board_name<<"\n";Solver solver(board,w,h);solver.solve();std::cout<<"\n";}}